# legacy-refactor-poc-context

레거시(Controller → Service → Repository/Client) 스타일로 시작한 코드를, **점진적으로 더 읽기 쉬운 실행 모델**로 진화시키기 위한 POC(Proof of Concept) 프로젝트입니다.

이 프로젝트의 관심사는 “정답 아키텍처”가 아니라, 다음과 같은 실무 문제를 **작게 재현하고 → 안전하게 정리하는 방법을 실험**하는 것입니다.

- 서비스가 서비스를 호출하면서 흐름이 콜스택에 숨어 **추적이 어려워지는 문제**
- 기능이 늘수록 “필요한 값”이 겹치고, 호출자가 모르면 서비스 내부에서 조회가 붙어 코드가 **누더기화되는 문제**
- 여러 유즈케이스에서 사용하는 정보의 조합이 늘어날 때, 재사용 단위를 잘못 잡으면 결합이 폭발하는 문제
- 분기별로 필요한 데이터만 로딩해야 하는데(불필요 호출/복잡도 방지), 구조가 그걸 방해하는 문제

> 버전(V1~Vn) 단위의 변화 기록은 필요할 때마다 추가할 예정입니다.

---

## Scenario (Demo)

이 프로젝트는 다음 두 가지 핵심 시나리오를 통해 레거시 코드의 문제점을 드러내고 개선합니다.

### 1. 프로모션 지급
> "서울에 사는 VIP 유저 중, 최근 1주일 내 구매 이력 및 포인트 수급 이력이 없는 사람에게만 포인트를 지급한다."

- **특징**: `지역` → `등급` → `구매이력` 순으로 조건을 체크하며, 조건 불만족 시 즉시 로직이 종료되어야 합니다.
- **Legacy의 문제**: 조건을 확인하기 위해 연관된 서비스들을 호출하다 보니, 불필요한 데이터 조회가 발생하고 `Service` 간의 결합도가 높아집니다.
- **Goal**: **Lazy Loading**과 **Context**를 도입하여, 로직의 가독성을 높이고 실제 필요한 시점에만 데이터를 조회하도록 개선합니다.

### 2. 악성 유저 제재 및 회수 (Write & Dependency Cycle)
> "악성 유저를 '정지' 처리하고, 최근 일주일간 부정 수급한 포인트와 혜택을 모두 '회수'한다."

- **특징**: `회원 상태 변경` 후 `포인트 회수`, `발급된 쿠폰 취소` 등 여러 도메인의 쓰기 작업이 순차적으로 발생합니다.
- **Legacy의 문제**: `MemberService`가 `PointService`를 호출하고, 반대로 `PointService`가 유저 확인을 위해 다시 `MemberService`를 의존하는 순환 참조의 늪에 빠지기 쉽습니다.
- **Goal**: UseCase를 도입과 **Interface Delegation**을 통해 의존성 방향을 한 곳으로 정리하고, 각 서비스가 서로를 모르게 격리합니다.

---

## Tech Stack

- Kotlin
- Spring Boot 3.x
- JDK 21
- Gradle Kotlin DSL
- Tests: Kotest + MockK
- Architecture rule tests: ArchUnit

---

## Getting Started

### Requirements
- JDK 21

### Run
```bash
./gradlew bootRun
```

### Test
```bash
./gradlew test
```

---

## Project Goal

이 프로젝트는 “도메인을 완벽히 모델링”하거나 “멋진 프레임워크 패턴”을 보여주기보다,

1. 레거시 방식으로 기능을 추가하면 어떤 문제가 생기는지 체감 가능한 형태로 재현
2. 그 문제를 해결하는 방향으로 구조를 바꿔가며 변화의 근거를 코드/테스트로 남김
3. 팀/리뷰어가 납득할 수 있는 수준의 규칙(예: 의존성 방향)을 테스트로 고정

하는 것을 목표로 합니다.

---

## Notes

- 외부 API 호출은 실제 HTTP로 붙이지 않을 수도 있습니다. (관심사가 “내부 구조”이기 때문)
- 대신 “분기별 로딩”과 “흐름 가시성” 같은 설계 의도를 테스트로 검증하는 방향을 선호합니다.
- 추후 필요 시 README에 각 단계(V1~Vn)의 설계 의도와 변화를 정리합니다.
- 이 프로젝트의 모든 코드는 '변경의 이유'를 설명하기 위해 존재합니다. V1(Legacy)은 틀린 코드가 아니라, 우리가 흔히 마주하는 현실적인 출발점입니다.